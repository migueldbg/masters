/* File: PlotRMS.C (ROOT macro).
 *
 * Author: Miguel Del Ben Galdiano (miguel.galdiano@gmail.com).
 * Date of creation : February 5 2020.
 * Last Update      : February 5 2020.
 *
 * Summary of File:
 *
 *    This macro takes the f90 histograms generated from a data set, a electron recoil (ER) only Monte Carlo (MC)
 *    simulation and a nuclear recoil (NR) only MC simulation. Each of the histograms considers a specific bin of
 *    the total charge, each of the bins with the same size, up to a maximum value. For each of the histograms, the
 *    macro takes the value of the root mean square (RMS), along its error, and saves it to the correct variable.
 *    Finally, the RMS are ploted as a function of total charge and the resulting plot is saved as a png and pdf.
 *
 *    IMPORTANT NOTE: This code assumes that the histograms were generated by utilizing the CreateF90Histograms
 *    macro, and therefore follows the logic of the directories defined there. If your histograms were not generated
 *    by the aforementioned macro, please make sure to do so, or else the code will not run.
 */

#include <array>
#include <iostream>

#include <TFile.h>
#include <TGraph.h>
#include <TH1.h>
#include <TKey.h>
#include <TObject.h>
#include <TString.h>
#include <TSystem.h>
#include <TTree.h>

/* TFile* CheckFile( TString path_name )
 *
 * Summary of CheckFile function:
 *
 *    The CheckFile function checks if a given file already exists and returns this information to the user.
 *    If the file exists, CheckFile returns it. If not, it creates it and then returns it.
 *
 * Parameters   : path_name >> The name of the desired file.
 *
 * Return value : TFile* file.
 */
TFile* CheckFile( TString path_name ){

  if (gSystem -> AccessPathName(path_name)) {
    std::cout << "The " << path_name << " file does not exist. Creating it..." << std::endl;
  } else {
    std::cout << "Opening file: " << path_name << std::endl;
  }

  TFile *file = new TFile(path_name, "UPDATE");
  if ( !(file -> IsOpen()) ) { std::cout << "Unable to open file." << std::endl;}

  return file;
}

/* TDirectory* MakeDirectory( const char* dir_name, const char* dir_title )
 *
 * Summary of MakeDirectory function:
 *
 *    The MakeDirectory function checks wether a given directory currently exists. If it does, it returns a
 *    pointer to it. If it doesn't, the function creates the directory with the given name in the current
 *    path and returns a pointer to it.
 *
 * Parameters   : dir_name  >> name of the desired directory.
 *                dir_title >> title of the directory, for bookeeping purpouses.
 *
 * Return value : TDirectory* directory.
 */
TDirectory* MakeDirectory( const char* dir_name, const char* dir_title ){

  TDirectory *directory = gDirectory -> GetDirectory(dir_name);
  if (!directory) directory = gDirectory -> mkdir(dir_name, dir_title);

  return directory;
}

/* Int_t NumberOfHistograms ( TDirectory* directory )
 *
 * Summary of NumberofHistograms function:
 *
 *    The NumberofHistograms function counts the number of one dimenstional histograms in a given directory
 *    by interating over all objects located in it and checking which inherit from TH1. It then returns the
 *    number of 1D histograms in the directory.
 *
 * Parameters   : directory >> a pointer to the the directory where the histograms are located.
 *
 * Return value : Int_t number_of_histograms.
 */
Int_t NumberOfHistograms( TDirectory* directory ){

  Int_t number_of_histograms = 0;
  TKey* key;

  TIter next( (TList *)directory -> GetListOfKeys() );

  while ( (key = (TKey *)next()) ) {
    TClass *object_class = gROOT -> GetClass( key->GetClassName() );
    if ( object_class -> InheritsFrom("TH1") ) {
      number_of_histograms++;
    }
  }

  return number_of_histograms;
}

void PlotRMS(int run){

  TString file_name = Form("hist_%d.root", run);
  TFile* hist_file = CheckFile(file_name);

  // --------------------- CREATING NECESSARY DIRECTORIES ---------------------- //
  hist_file -> cd();
  TDirectory* RMS_analysis_dir   = MakeDirectory("RMS_analysis", "RMS_analysis");

  RMS_analysis_dir -> cd();
  TDirectory* histograms_dir     = MakeDirectory("histograms", "histograms");

  histograms_dir -> cd();
  TDirectory* f90_histograms_dir = MakeDirectory("f90", "f90");

  f90_histograms_dir -> cd();
  TDirectory* data_dir           = MakeDirectory("data", "data");
  TDirectory* monte_carlo_dir    = MakeDirectory("monte_carlo", "monte_carlo");

  data_dir -> cd();
  TDirectory* da_both_dir         = MakeDirectory("both","both");
  TDirectory* da_er_dir           = MakeDirectory("ER","ER");
  TDirectory* da_nr_dir           = MakeDirectory("NR","NR");

  monte_carlo_dir -> cd();
  TDirectory* mc_er_dir           = MakeDirectory("ER","ER");
  TDirectory* mc_nr_dir           = MakeDirectory("NR","NR");
  // --------------------------------------------------------------------------- //

  Int_t number_of_histograms = NumberOfHistograms(da_both_dir);

  Double_t RMS_da_er[number_of_histograms];      Double_t RMS_da_nr[number_of_histograms];
  Double_t RMSerr_da_er[number_of_histograms];   Double_t RMSerr_da_nr[number_of_histograms];

  Double_t RMS_mc_er[number_of_histograms];      Double_t RMS_mc_nr[number_of_histograms];
  Double_t RMSerr_mc_er[number_of_histograms];   Double_t RMSerr_mc_nr[number_of_histograms];

  Double_t charge_total[number_of_histograms];

  TH1F* htemp = 0;

  for ( int i = 0; i < number_of_histograms; i++ ){

    htemp = (TH1F *)da_er_dir -> Get( Form("f90_histogram_er_%d", i+1) );
    RMS_da_er[i] = htemp -> GetRMS();  RMSerr_da_er[i] = htemp -> GetRMSError();

    htemp = (TH1F *)da_nr_dir -> Get( Form("f90_histogram_nr_%d", i+1) );
    RMS_da_nr[i] = htemp -> GetRMS();  RMSerr_da_nr[i] = htemp -> GetRMSError();

    htemp = (TH1F *)mc_er_dir -> Get( Form("f90_histogram_mcer_%d", i+1) );
    RMS_mc_er[i] = htemp -> GetRMS();  RMSerr_mc_er[i] = htemp -> GetRMSError();

    htemp = (TH1F *)mc_nr_dir -> Get( Form("f90_histogram_mcnr_%d", i+1) );
    RMS_mc_nr[i] = htemp -> GetRMS();  RMSerr_mc_nr[i] = htemp -> GetRMSError();

    charge_total[i] = 20*(i+1) - 10;
  }

  TGraph* gr = new TGraph(number_of_histograms, charge_total, RMS_da_er);
  gr -> Draw("A*");


  // get the desired histogram -> get the rms and its error -> save it -> close the histogram
  // plot the rms
  // save the images


}

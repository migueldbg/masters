/* File: PlotRMS.C (ROOT macro).
 *
 * Author: Miguel Del Ben Galdiano (miguel.galdiano@gmail.com).
 * Date of creation : February 5 2020.
 * Last Update      : February 5 2020.
 *
 * Summary of File:
 *
 *    This macro takes the f90 histograms generated from a data set, a electron recoil (ER) only Monte Carlo (MC)
 *    simulation and a nuclear recoil (NR) only MC simulation. Each of the histograms considers a specific bin of
 *    the total charge, each of the bins with the same size, up to a maximum value. For each of the histograms, the
 *    macro takes the value of the root mean square (RMS), along its error, and saves it to the correct variable.
 *    Finally, the RMS are ploted as a function of total charge and the resulting plot is saved as a png and pdf.
 *
 *    IMPORTANT NOTE: This code assumes that the histograms were generated by utilizing the CreateF90Histograms
 *    macro, and therefore follows the logic of the directories defined there. If your histograms were not generated
 *    by the aforementioned macro, please make sure to do so, or else the code will not run.
 */

#include <array>
#include <iostream>
#include <stdlib.h>

#include <TCanvas.h>
#include <TFile.h>
#include <TGraph.h>
#include <TH1.h>
#include <TKey.h>
#include <TLegend.h>
#include <TMath.h>
#include <TObject.h>
#include <TString.h>
#include <TSystem.h>
#include <TTree.h>

/* TFile* CheckFile( TString path_name )
 *
 * Summary of CheckFile function:
 *
 *    The CheckFile function checks if a given file already exists and returns this information to the user.
 *    If the file exists, CheckFile returns it. If not, it creates it and then returns it.
 *
 * Parameters   : path_name >> The name of the desired file.
 *
 * Return value : TFile* file.
 */
TFile* CheckFile( TString path_name ){

  if (gSystem -> AccessPathName(path_name)) {
    std::cout << "The " << path_name << " file does not exist. Creating it..." << std::endl;
  } else {
    std::cout << "Opening file: " << path_name << std::endl;
  }

  TFile *file = new TFile(path_name, "UPDATE");
  if ( !(file -> IsOpen()) ) { std::cout << "Unable to open file." << std::endl;}

  return file;
}

// ************ REWRITE THE FUNCTION BELOW ******************* //
// make it so that it takes to TGraphErrors object and constructs a new TGraphErros as the difference between them.  

TGraph* GraphDiff( Double_t* array1, Double_t* array2, Double_t* y_array, Int_t size, Int_t base_array = 0 ){

  Double_t diff_array[size];

  for (Int_t i = 0; i < size; i++){
    if (base_array == 0) {
      diff_array[i] = TMath::Abs( array1[i] - array2[i] );
    } else if (base_array == 1) {
      diff_array[i] = TMath::Abs( array1[i] - array2[i] ) / array1[i];
    } else if (base_array == 2) {
      diff_array[i] = TMath::Abs( array1[i] - array2[i] ) / array2[i];
    }
  }

  TGraph* graph_diff = new TGraph(size, y_array, diff_array);

  return graph_diff;
}

/* TDirectory* MakeDirectory( const char* dir_name, const char* dir_title )
 *
 * Summary of MakeDirectory function:
 *
 *    The MakeDirectory function checks wether a given directory currently exists. If it does, it returns a
 *    pointer to it. If it doesn't, the function creates the directory with the given name in the current
 *    path and returns a pointer to it.
 *
 * Parameters   : dir_name  >> name of the desired directory.
 *                dir_title >> title of the directory, for bookeeping purpouses.
 *
 * Return value : TDirectory* directory.
 */
TDirectory* MakeDirectory( const char* dir_name, const char* dir_title ){

  TDirectory *directory = gDirectory -> GetDirectory(dir_name);
  if (!directory) directory = gDirectory -> mkdir(dir_name, dir_title);

  return directory;
}

/* Int_t NumberOfHistograms ( TDirectory* directory )
 *
 * Summary of NumberofHistograms function:
 *
 *    The NumberofHistograms function counts the number of one dimenstional histograms in a given directory
 *    by interating over all objects located in it and checking which inherit from TH1. It then returns the
 *    number of 1D histograms in the directory.
 *
 * Parameters   : directory >> a pointer to the the directory where the histograms are located.
 *
 * Return value : Int_t number_of_histograms.
 */
Int_t NumberOfHistograms( TDirectory* directory ){

  Int_t number_of_histograms = 0;
  TKey* key;

  TIter next( (TList *)directory -> GetListOfKeys() );

  while ( (key = (TKey *)next()) ) {
    TClass *object_class = gROOT -> GetClass( key->GetClassName() );
    if ( object_class -> InheritsFrom("TH1") ) {
      number_of_histograms++;
    }
  }

  return number_of_histograms;
}

/* TGraphErrors WriteGraph (TDirectory* directory, Int_t n, Double_t* x, Double_t* y, Double_t* ex = 0, Double_t* ey = 0,
                            const char* title = "", const char* name = "graph", Int_t ms = 22)
 *
 * Summary of WriteGraph function:
 *
 *    The WriteGraph function takes the necessary parameters to construct a TGraphErrors object and does. It
 *    can also take some parameters to determine the name, title and marker style of the resulting graph. The
 *    code than writes the graph to the given directory and returns it.
 *
 * Parameters   : directory       >> where to write the graph.
 *                title           >> title of the graph ("TITLE; XAXIS; YAXIS").
 *                name            >> name of the graph.
 *                ms              >> indicates the MarkerStyle to be used.
 *                mc              >> indicates the MarkerColor to be used.
 *                n, x, y, ex, ey >> necessary parameters to construct a TGraphErros object.
 *
 * Return Value : TGraphErros* graph
 */
TGraphErrors* WriteGraph( TDirectory* directory, Int_t n, Double_t* x, Double_t* y, Double_t* ex = 0, Double_t* ey = 0,
                          const char* title = "", const char* name = "graph", Int_t ms = 22, Int_t mc = 1){

  TGraphErrors* graph = new TGraphErrors(n, x, y, ex, ey);
  graph -> SetTitle(title);
  graph -> SetName(name);
  graph -> SetMarkerStyle(ms);
  graph -> SetMarkerColor(mc);
  graph -> SetMarkerSize(1.5);
  graph -> SetLineColor(mc);
  graph -> GetXaxis() -> SetRangeUser(-50., 1100.);
  graph -> GetXaxis() -> SetTitle("Charge (PE)");
  graph -> GetYaxis() -> SetTitle("RMS");

  directory -> WriteObject(graph, name, "OverWrite");

  return graph;
}

void PlotRMS(int run){

  TString file_name = Form("hist_%d.root", run);
  TFile* hist_file = CheckFile(file_name);

  // --------------------- CREATING NECESSARY DIRECTORIES ---------------------- //
  hist_file -> cd();
  TDirectory* RMS_analysis_dir   = MakeDirectory("RMS_analysis", "RMS_analysis");

  RMS_analysis_dir -> cd();
  TDirectory* histograms_dir     = MakeDirectory("histograms", "histograms");
  TDirectory* graphs_dir         = MakeDirectory("graphs", "graphs");

  histograms_dir -> cd();
  TDirectory* f90_histograms_dir = MakeDirectory("f90", "f90");

  f90_histograms_dir -> cd();
  TDirectory* data_dir           = MakeDirectory("data", "data");
  TDirectory* monte_carlo_dir    = MakeDirectory("monte_carlo", "monte_carlo");

  data_dir -> cd();
  TDirectory* da_both_dir         = MakeDirectory("both","both");
  TDirectory* da_er_dir           = MakeDirectory("ER","ER");
  TDirectory* da_nr_dir           = MakeDirectory("NR","NR");

  monte_carlo_dir -> cd();
  TDirectory* mc_er_dir           = MakeDirectory("ER","ER");
  TDirectory* mc_nr_dir           = MakeDirectory("NR","NR");
  // --------------------------------------------------------------------------- //

  Int_t number_of_histograms = NumberOfHistograms(da_both_dir);

  Double_t RMS_da_er[number_of_histograms];      Double_t RMS_da_nr[number_of_histograms];
  Double_t RMSerr_da_er[number_of_histograms];   Double_t RMSerr_da_nr[number_of_histograms];

  Double_t RMS_mc_er[number_of_histograms];      Double_t RMS_mc_nr[number_of_histograms];
  Double_t RMSerr_mc_er[number_of_histograms];   Double_t RMSerr_mc_nr[number_of_histograms];

  Double_t charge_total[number_of_histograms];

  TH1F* htemp = 0;

  for ( int i = 0; i < number_of_histograms; i++ ){

    htemp = (TH1F *)da_er_dir -> Get( Form("f90_histogram_er_%d", i+1) );
    RMS_da_er[i] = htemp -> GetRMS();  RMSerr_da_er[i] = htemp -> GetRMSError();

    htemp = (TH1F *)da_nr_dir -> Get( Form("f90_histogram_nr_%d", i+1) );
    RMS_da_nr[i] = htemp -> GetRMS();  RMSerr_da_nr[i] = htemp -> GetRMSError();

    htemp = (TH1F *)mc_er_dir -> Get( Form("f90_histogram_mcer_%d", i+1) );
    RMS_mc_er[i] = htemp -> GetRMS();  RMSerr_mc_er[i] = htemp -> GetRMSError();

    htemp = (TH1F *)mc_nr_dir -> Get( Form("f90_histogram_mcnr_%d", i+1) );
    RMS_mc_nr[i] = htemp -> GetRMS();  RMSerr_mc_nr[i] = htemp -> GetRMSError();

    charge_total[i] = 20*(i+1) - 10;
  }

  TGraphErrors* da_er_graph = WriteGraph( graphs_dir, number_of_histograms, charge_total, RMS_da_er, 0, RMSerr_da_er,
                                          "RMS of f90 Histograms (ER)", "f90RMSxCharge_total_er", 22, 40);
  TGraphErrors* da_nr_graph = WriteGraph( graphs_dir, number_of_histograms, charge_total, RMS_da_nr, 0, RMSerr_da_nr,
                                          "RMS of f90 Histograms (NR)", "f90RMSxCharge_total_nr", 23, 40);
  TGraphErrors* mc_er_graph = WriteGraph( graphs_dir, number_of_histograms, charge_total, RMS_mc_er, 0, RMSerr_mc_er,
                                          "RMS of f90 Histograms (MC ER)", "f90RMSxCharge_total_mcer", 22, 30);
  TGraphErrors* mc_nr_graph = WriteGraph( graphs_dir, number_of_histograms, charge_total, RMS_mc_nr, 0, RMSerr_mc_nr,
                                          "RMS of f90 Histograms (MC NR)", "f90RMSxCharge_total_mcnr", 23, 30);

  Double_t y_size = 500.;
  Double_t x_size = 1.61803398875 * y_size;

  TCanvas* er_canvas = new TCanvas("er_canvas", "er_canvas", x_size, y_size);

  TMultiGraph* er_multigraph = new TMultiGraph();
  er_multigraph -> Add(da_er_graph); er_multigraph -> Add(mc_er_graph);
  er_multigraph -> SetTitle("Data and MC Comparision (1220, ER); Charge (PE); RMS");
  er_multigraph -> Draw("ALP");

  TLegend* er_legend = new TLegend(0.674067, 0.776657, 0.924319, 0.926513);
  er_legend -> AddEntry( da_er_graph, "Data", "lep" );
  er_legend -> AddEntry( mc_er_graph, "Monte Carlo", "lep" );
  er_legend -> Draw();

  TCanvas* nr_canvas = new TCanvas("nr_canvas", "nr_canvas", x_size, y_size);

  TMultiGraph* nr_multigraph = new TMultiGraph();
  nr_multigraph -> Add(da_nr_graph); nr_multigraph -> Add(mc_nr_graph);
  nr_multigraph -> SetTitle("Data and MC Comparision (1220, NR); Charge (PE); RMS");
  nr_multigraph -> Draw("ALP");

  TLegend* nr_legend = new TLegend(0.674067, 0.776657, 0.924319, 0.926513);
  nr_legend -> AddEntry( da_nr_graph, "Data", "lep" );
  nr_legend -> AddEntry( mc_nr_graph, "Monte Carlo", "lep" );
  nr_legend -> Draw();

  /*
  TGraph* test = GraphDiff( RMS_da_er, RMS_mc_er, charge_total, number_of_histograms, 1 );
  TCanvas* c1 = new TCanvas("c1");
  test -> SetMaximum(1.);
  test-> SetMarkerStyle(21);
  test -> Draw("APL");
  */

  er_canvas -> SaveAs("f90RMS v Charge (ER).pdf");    er_canvas -> SaveAs("f90RMS v Charge (ER).png");
  nr_canvas -> SaveAs("f90RMS v Charge (NR).pdf");    nr_canvas -> SaveAs("f90RMS v Charge (NR).png");

  Double_t* test =  da_nr_graph ->GetX();
  cout << test[0] << endl;
}
